= Blueprint Hooking System

[IMPORTANT]
====
This feature slated for SML 3.11 has not been released yet, and is not in the `dev` branch yet!
The contents of this page will change frequently!
====

SML3.11 introduces a new Blueprint Hooking system that allows modifying the behavior of existing Blueprint functions via custom code.
Your code can be run before or after the original function and can modify the function's inputs, return values, or cancel its execution.
It can also replace portions on the function logic (TODO verify).

Blueprint Hooks are created as blueprint assets and have full knowledge of blueprint asset structures and function signatures.

[NOTE]
====
Hooking of {cpp}-implemented functions is covered on the xref:Development/Cpp/hooking.adoc[Native Hooking] page.
====

== Creating a Hook Blueprint

TODO how many hooks can be in one blueprint?

Within the Unreal Editor, create a new Blueprint of the type "Blueprint Hook"

image::Development/ModLoader/BlueprintHooks/CreateBlueprintHook.png[Create Blueprint Hook Asset]

Next, create a new function to handle the logic of your hook.
The first parameter should be the type of Blueprint you are hooking.
Subsequent parameters should be ...idk... TODO

image::Development/ModLoader/BlueprintHooks/NewFunction.png[New Function]

TODO how to go between hook graph and function graphs

Go back to the Graph, right-click, and create the type of hook you want.
Each type has an on-hover tooltip that explains what it does.

image::Development/ModLoader/BlueprintHooks/CreateHook.png[Create Hook]

Fill out the drop-downs to specify what class's function you are hooking.

image::Development/ModLoader/BlueprintHooks/FillDropdowns.png[Fill dropdowns]

Add a Target Specifier. These have on-hover tooltips that explain what they do.

image::Development/ModLoader/BlueprintHooks/TargetSpecifierTooltip.png[Target Specifier with tooltip]

image::Development/ModLoader/BlueprintHooks/TargetSpecifierConnected.png[Target Specifier]

[id="Register"]
== Registering the Hook

Hooks must be registered in a
xref:Development/ModLoader/ModModules.adoc[Game Instance Module] to be applied in-game.
Create a Mod Game Instance Module if you don't already have one and add your new hook to the "Blueprint Hooks" array.

image::Development/ModLoader/BlueprintHooks/RegisterHook.png[Register Hook in Game Instance Module]

== Limitations and Workarounds

=== Event Graph Nodes

Because Blueprint Hooks exist as functions, some nodes you may be used to from Event Graphs are not available, such as Latent Action nodes like Delay.

To work around this, implement your logic in an Event Graph somewhere else,
such as a Mod Subsystem or your Mod Game World Module,
then calling that event from the Hook Function.

image::Development/ModLoader/BlueprintHooks/LatentActionWorkaround.png[Game World Module workaround]

=== Unregistering Blueprint Hooks

Once you have hooked a blueprint function, there is currently no way to unhook it without fully exiting Satisfactory.
This is why blueprint hooks are registered in a Game Instance Module.

You can work around this by having your hook code check a flag in a mod subsystem or your game instance module to determine if the hook should execute.

=== Hooking and Dedicated Servers

TODO does this still happen with the new hooking system?

Some blueprints (like UI blueprints) do not exist in the dedicated server build.
If your mod attempts to hook such a blueprint in a dedicated server, it will crash the server.
You can use the global function `IsRunningDedicatedServer()` to skip hooking in this case.

== Viewing Blueprint Function Implementations

Understanding what base-game blueprint functions do can be troublesome as we don't have their source code
and the starter project only contains xref:Development/BeginnersGuide/StarterProjectStructure.adoc#PlaceholderSystem[placeholders of blueprint assets].

To assist with this process, SML implements the `-DumpBlueprintPatchingResults` command line argument.
When the game is launched with this argument,
SML will dump the bytecode of all blueprint hooked functions to the log in a relatively human-readable format.

Note that it is also possible to use xref:Development/ExtractGameFiles.adoc#FModel[FModel] to dump an asset as JSON
and view the blueprint bytecode in a less-readable format.

== TODO

Stuff from mircea messages to organize

=== Blueprint Hook info

https://discord.com/channels/555424930502541343/562722670974599227/1359689684237680751

FBlueprintHookManager::HookBlueprintFunction -> Blueprint Hook blueprints
* can do matching instead of just instruction index (more stable ™️), and insert the hook before/after/replace the existing statement
  * the BP hooking internals are transpiling the bytecode, but transpiling is not exposed to the user
* hooks are defined in a Blueprint Hook blueprint where the graph can contain
  * target specifiers (matchers) - which statements/expressions to match
    * constant (can choose type and value)
    * function call
    * function entry/exit
    * function return value
    * property read/write
    * parent expression (takes another specifier as input)
    * operand (takes another specifier as input)
    * selector (first/single/all/stuff) (takes another specifier as input)
  * hooks - what to apply to the statements/expressions filtered above (takes target specifier chain as input)
    * insert (before/after/replace, will resolve to the statement if targeting an expression)
    * redirect (for replacing non-statement expressions, e.g. function call argument, must return same type)
    * they take a function to apply as the hook
      * the functions exist in the same hook blueprint
      * can have arguments with the same name as variables available in the hook (local variables, global variables, and temp variables like function return values - need to dump the BP function to see the temp names)
      * you can also write to the argument to write to the variable
      * special arguments:
        * Target (the object)
        * TargetReturnValue (ReturnValue of the of the hooked function, but renamed to avoid conflicts with this function's ReturnValue)
        * redirect hooks
          * OriginalValue
        * insert hooks
          * HookTarget (the expression targeted by the hook, if not a statement already)
          * AssignmentTarget (when hooking an assignment statement, the variable to assign to)

=== Hook Function info

For the hook function, the inputs will be mapped using their name to
* global variables - object instance
* local variables - function inputs, function locals, and function temps (which you can check for in a BP code dump, either `-DumpBlueprintPatchingResults` which generates pseudocode, or in FModel which generates a json very similar to the asset dump)
* Target - special hooking argument that resolves to the object instance the hooked function was running
* TargetReturnValue - special hooking argument that resolves to the hooked function's ReturnValue
* HookTarget - special hooking argument that resolves to the expression the hook was pointing to, if it wasn't pointing to a statement
* AssignmentTarget - special hooking argument that resolves to the variable on the left side of an assignment statement, if that's what was hooked
* OriginalValue - special hooking argument that resolves to the original value when using redirect hooks (replacing an expression inside a statement, rather than an insert hook which goes before/replace/after a statement), is required in this case

== Blueprint Hooking from {cpp}

It is not currently possible to hook blueprint functions from {cpp} code using SML's systems.

Previous versions of SML allowed hooking blueprint functions from {cpp} code,
but because the {cpp} side is unaware of the structure of assets defined on the blueprint side,
these hooks were always in a messy and brittle state of requiring lots of reflection and hardcoded assumptions to work.
The only way to mitigate this brittleness was to have the hook call a blueprint-implemented function.
The modern system removes the middleman by having blueprint hooks defined and implemented on the asset side,
giving them full knowledge of asset structure.

// TODO mircea discussion about custom thunks?
